# renderer/flask_renderer.py

import os
import secrets
import logging

# Defensive imports - handle missing dependencies gracefully
try:
    from flask import Flask, render_template, get_flashed_messages, jsonify
    FLASK_AVAILABLE = True
except ImportError as e:
    logging.error(f"Flask not available: {e}")
    FLASK_AVAILABLE = False
    # Create dummy classes to prevent import errors
    class Flask: pass
    def render_template(*args, **kwargs): return ""
    def get_flashed_messages(): return []
    def jsonify(data): return str(data)

logger = logging.getLogger(__name__)

class FlaskRenderer:
    def __init__(self, config):
        if not FLASK_AVAILABLE:
            raise RuntimeError("Flask is not available. Install with: pip install Flask")
        
        if not config:
            raise ValueError("Configuration must be provided for FlaskRenderer")
        
        # Setup paths
        base_dir = os.path.abspath(os.path.dirname(__file__))
        root_dir = os.path.abspath(os.path.join(base_dir, ".."))

        # Initialize Flask app
        self.app = Flask(
            __name__,
            template_folder=os.path.join(root_dir, "templates"),
            static_folder=os.path.join(root_dir, "static")
        )

        # Store config
        self.config = config
        self.port = config.get("FLASK_RUN_PORT", 8574)

        # Configure app
        self._configure_app()
        
        # Register routes
        self._register_routes()
        
        # Run startup tasks
        self._startup_tasks()

        logger.info(f"üöÄ FlaskRenderer initialized successfully")

    def _configure_app(self):
        """Configure Flask app settings"""
        # Secret key
        secret_key = self.config.get("SECRET_KEY")
        self.app.secret_key = secret_key or secrets.token_urlsafe(32)

        # Apply config to Flask
        for key, value in self.config.items():
            self.app.config[key] = value

        # Flask-specific settings
        self.app.config.update({
            'MAX_CONTENT_LENGTH': 100 * 1024 * 1024,  # 100MB
            'SEND_FILE_MAX_AGE_DEFAULT': 0,  # No caching
        })

    def _register_routes(self):
        """Register all Flask routes"""
        
        @self.app.route("/")
        def index():
            """Main page - handle with or without cleanup"""
            session_id = getattr(self.app, "session_id", None)
            files = getattr(self.app, "processing_results", [])
            messages = get_flashed_messages()

            # Try to mark session active if cleanup is available
            if session_id:
                try:
                    from utils.cleanup import mark_session_active
                    session_dir = os.path.join(
                        self.config.get("SESSIONS_ROOT", "uploads"), 
                        f"session_{session_id}"
                    )
                    if os.path.exists(session_dir):
                        mark_session_active(session_dir)
                        logger.debug(f"üìç Session {session_id} marked active")
                except (ImportError, Exception) as e:
                    logger.debug(f"Could not mark session active: {e}")

            return render_template(
                "index.html", 
                session=session_id, 
                files=files, 
                messages=messages
            )

        @self.app.route("/health")
        def health_check():
            """Health check for monitoring"""
            return jsonify({
                "status": "healthy",
                "version": "0.3.0",
                "port": self.port
            })

        @self.app.errorhandler(404)
        def not_found(error):
            """Handle 404 errors"""
            return jsonify({"error": "Not found"}), 404

        @self.app.errorhandler(500)
        def internal_error(error):
            """Handle 500 errors"""
            logger.error(f"Internal error: {error}")
            return jsonify({"error": "Internal server error"}), 500

    def _startup_tasks(self):
        """Run startup tasks - cleanup if available"""
        try:
            from utils.cleanup import cleanup_orphaned_sessions
            sessions_root = self.config.get("SESSIONS_ROOT", "uploads")
            if os.path.exists(sessions_root):
                cleanup_orphaned_sessions(sessions_root, max_age_hours=1)
                logger.info(f"‚úÖ Startup cleanup completed for {sessions_root}")
            else:
                logger.info(f"üìÅ Sessions directory doesn't exist: {sessions_root}")
        except ImportError:
            logger.info("‚ö†Ô∏è Cleanup module not available - skipping")
        except Exception as e:
            logger.error(f"‚ùå Startup cleanup failed: {e}")

    def run(self, **kwargs):
        """Run Flask development server"""
        if not FLASK_AVAILABLE:
            raise RuntimeError("Flask is not available")

        run_config = {
            "host": "0.0.0.0",
            "port": self.port,
            "debug": self.config.get("LOG_LEVEL", "INFO") == "DEBUG",
            "use_reloader": False,
            "threaded": True,
        }
        run_config.update(kwargs)

        logger.info(f"üåê Starting Flask server at http://{run_config['host']}:{run_config['port']}")
        
        try:
            self.app.run(**run_config)
        except KeyboardInterrupt:
            logger.info("üõë Server stopped by user")
        except Exception as e:
            logger.error(f"‚ùå Server error: {e}")
            raise

    def get_wsgi_app(self):
        """Get WSGI app for production deployment - REQUIRED METHOD"""
        if not FLASK_AVAILABLE:
            raise RuntimeError("Flask is not available")
        return self.app

    # Alias for backwards compatibility
    @property
    def wsgi_app(self):
        return self.get_wsgi_app()